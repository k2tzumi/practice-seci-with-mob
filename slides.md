---
# You can also start simply with 'default'
theme: seriph
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
background: https://cover.sli.dev
# some information about your slides (markdown enabled)
title: モブワークによるSECIモデルの実践
info: |
  PHP Conference Japan 2025  
  https://phpcon.php.gr.jp/2025/

# apply unocss classes to the current slide
class: text-center
# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
addons:
  - '@katzumi/slidev-addon-qrcode'
  - slidev-addon-components
  - slidev-addon-rabbit
---

# モブワークによるSECIモデルの実践
PHP Conference Japan 2025 Jul 19, 2025.  
v0.0.1  
@katzumi(かつみ)

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">
    Press Space for next page <carbon:arrow-right class="inline"/>
  </span>
</div>

<div class="abs-br m-6 flex gap-2">
  <button @click="$slidev.nav.openInEditor()" title="Open in Editor" class="text-xl slidev-icon-btn opacity-50 !border-none !hover:text-white">
    <carbon:edit />
  </button>
  <a href="https://github.com/k2tzumi/decision-table-implementation-tips" target="_blank" alt="GitHub" title="Open in GitHub"
    class="text-xl slidev-icon-btn opacity-50 !border-none !hover:text-white">
    <carbon-logo-github />
  </a>
</div>

<!--
The last comment block of each slide will be treated as slide notes. It will be visible and editable in Presenter Mode along with the slide. [Read more in the docs](https://sli.dev/guide/syntax.html#notes)
-->

---
transition: fade-out
layout: two-cols-header
---

# 自己紹介

katzumi（かつみ）と申します。

「障害のない社会をつくる」をビジョンに掲げている「LITALICO」という会社に所属しています
<a href="https://litalico.co.jp/">
<img src="https://litalico.co.jp/ogp.png" class="w-40" />
</a>

以下のアカウントで活動しています。

::left::

<div class="float-left">
<img src="https://pbs.twimg.com/profile_images/1768978237210935296/idy9J4l6_400x400.jpg" class="rounded-full w-40 mr"/>  
<simple-icons-x /> <a href="https://twitter.com/katzchum">katzchum</a></div>  
<QRCode :width="180" :height="180" value="https://twitter.com/katzchum" color="4329B9" image="Logo_of_X.svg" />

::right::

<img src="https://avatars.githubusercontent.com/u/1182787?v=4" class="rounded-full w-40 mr-12"/>

<logos-github-octocat /> [k2tzumi](https://github.com/k2tzumi)  
<simple-icons-zenn /> [katzumi](https://zenn.dev/katzumi)  

<br />

<style>
h1 {
  background-color: #2B90B6;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}
</style>

---
layout: two-cols-header
transition: fade-out
---


# お願い 🙏

写真撮影、SNS での実況について

登壇者の励みになるので是非ともご意見やご感想など、フィードバック頂けると助かります mm  
あとでスライドを公開します

::left::

<Transform :scale="2.5">
　　　🙆‍♀📷<ph-projector-screen-chart-light /><br />
　　　🙅‍♂📹💸<br />
　　　🙅📸👨‍👦‍👦<br />
</Transform>

::right::

<br />
<Transform :scale="2">
<fa6-brands-square-x-twitter />
</Transform>
<br />
<a href="https://x.com/search?q=%23phpcon%20%23track5&f=live">#phpcon #track5</a>


<!-- 本セッションでは、撮影やSNS拡散を歓迎しています。ご自由に写真を撮影して、XなどのSNSでシェアしてください。 　　
ただし、以下の点にご注意ください。　　

著作権などの法的な問題を避けるために、スライドや登壇者の写真や動画を無断で商用利用しないでください。　　
他の参加者のプライバシーや迷惑にならないように、撮影や投稿する際には配慮してください。　　
SNSでシェアする際には、ハッシュタグ「#phpcon_nagoya #s」をつけてください。　　
これにより、本セッションの関連情報を簡単に検索できるようになります。 -->

---
layout: default
transition: slide-up
---

# はじめに
セッションの概要と目的。お断りとか

* **🙇PHPの直接的な技術トピックは出てきません**  
* **対象となる聴衆**  
モブワークに興味がある（実践している）方・複雑なドメインを扱っている方
* **本セッションの位置づけ**  
技術的な内容ではなく、チーム開発プロセスと知識共有の方法論に焦点  
5年間のモブワークの実践を通じて得られた知見に基づきます。
* **本セッションの主な狙い**  
プロジェクトへのモブワーク導入を検討するきっかけの提供

---
layout: statement
transition: fade
---

# モブワーク(Mob Work)
# とは？<v-click>の前に</v-click>

---
layout: statement
---

# モブプログラミング
# (Mob Programming)


---
layout: two-cols-header
---

# モブプログラミングとは
ソフトウェア・チーミングのスタイルの一種

::left::

## 定義
- 2011年 **Woody Zuill氏** により提唱
  <blockquote>
  <p>「すべての優秀な人材が、同じ時に同じ場所で、同じコンピュータで協力して一つのことに取り組む」</p>
  </blockquote>
- **ペアプログラミング**を拡張
- チームメンバー全員を含めるようにスケールアップ
- 「進化的なステップ」と定義

<br />
<br />
<br />
<br />
<br />

::right::

## 基本的な考え方
- チームメンバー全員が**同じコンピュータシステム**を使用
- **同じ画面**を見ながら作業
- **同じ時間**を共有
- **同じ問題**を解決
- **一つのタスク**に非常に集中的に取り組む


---
layout: two-cols-header
---

# モブプログラミングにおけるチームの役割分担
ペアプログラミングとほぼ同じ役割分担

::left::

## ドライバー 👨‍💻
<v-clicks>

- **コードを書く**機械的なタイピング作業を担当
- **一人のメンバー**が担当
- **定期的にローテーション**される  
通常15-30分で交代
- 指示を受けて実装に集中

</v-clicks>

<br />
<br />
<br />
<br />
<br />
<br />


::right::

## ナビゲーター 🧭
<v-clicks>

- **問題解決を共同で行う**
- **ドライバーに指示**を出す
- **残りのメンバー全員**が担当  
次のドライバーをナビゲーター(1名)として残りのメンバーをモブと呼ぶ場合もあります
- 戦略的思考と方向性を提供

</v-clicks>

---
layout: center
class: text-center
---

# モブプログラミングの目的

<v-click>

## チームが共同で作業し、共有し、学ぶことを通じて  
## **チーム全体のパフォーマンスを向上させる**

</v-click>

---
layout: default
---

# モブプログラミングの主な利点

<div class="grid grid-cols-2 gap-6 pt-4 -mb-6">

<v-clicks>

- 🤝 **チーム内の知識共有の促進**  
個人の暗黙知をリアルタイムでチーム全体に共有
- ✨ **コード品質の向上**  
コードレビューをリアルタイムで行い、品質向上
- 📚 **メンバーの学習機会の促進**  
チーム全体での学習と成長を促進
- 💡 **問題解決能力の向上**  
熟練者の思考プロセスや判断基準に触れる
</v-clicks>

<v-clicks>

- 🔄 **属人性の解決**  
チーム全体として理解を深める
- ⚡ **コードレビューコストの低減**  
実装が完了したらマージReadyな状態となる
- 🚀 **新規メンバーのオンボーディングのスムーズ化**  
リアルタイムでの実践的な学習、即時フィードバック、密なコミュニケーションを通じたチームへの自然な溶け込み
- 🛡️ **開発中のハマり防止**  
問題を一人で抱え込まない。多様な視点と専門知識を結集して問題を解消する
</v-clicks>

</div>

<v-click>

<div class="pt-8">
  <div class="bg-blue-50 border-l-4 border-blue-400 p-4 rounded">
    <p class="text-blue-700 font-semibold">
      これらの利点により、チーム全体のパフォーマンスが向上します
    </p>
  </div>
</div>

</v-click>

---
layout: statement
transition: fade
---

# モブワーク(Mob Work)
話を戻します

---

# モブプログラミングとモブワークの違い
チームの集合知を活用し、知識共有とコラボレーションを促進する点では共通

* **モブワークの適用範囲**  
  * 工程: 要件定義、設計、製造、テスト、運用保守
  * 業務: 文書作成、設計、企画、分析など、プログラミングも含む様々な業務
* **モブワークの成果物**  
コードも含む多様な成果物  （企画書、設計図、プレゼンテーション資料、ログ調査結果など）
* **モブワークのメンバー**  
開発者に限定されない。プロダクトオーナー、テスター、UI/UXスタッフも参加可能
* **モブワークが扱う問題**  
問題自体が曖昧で、解決方法も複数存在  
逆にモブプログラミングは、問題設定、制約条件、解決手順が明確


<br />

<v-clicks>

<div class="fusen">
プログラミングに限った話ではないので、以降はモブワークとしてお話します
</div>

</v-clicks>

---
layout: two-cols-header
---

# モブワークにおける効率に対する考え方
大勢で一つの仕事に取り組むのは非効率なのではないか？

::left::

<v-click>

## ❌ リソース効率
- **個人の稼働率を最大化**  
「忙しく働いているか？」
- 個別最適化に焦点
- 従来の考え方

</v-click>

<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />

::right::

<v-click>

## ✅ フロー効率
- **価値提供までの時間を最小化**  
「価値を早く届けられるか？」
- 全体最適化に焦点
- **モブプログラミングが重視**  
  - 手戻りの削減
  - 待ち時間の解消
  - 品質問題の早期発見

</v-click>

---
layout: two-cols-header
---

# モブワークが解決する「隠れた非効率」
中長期的な視点（バグ修正、仕様変更、ナレッジ共有に係るコスト）が重要


**🐛 品質問題のコスト**  
- バグ修正：発見が遅れるほど修正コストが指数的に増加
- リファクタリング：品質ばらつきによる技術的負債の蓄積のスピード増加
- 障害対応：知識のサイロ化。初動遅れによる復旧コスト増加

::left::

**🔄 コミュニケーションコスト**  
- コードレビュー：非同期レビューの往復時間
- 質問・相談：「今、時間ありますか？」の積み重ね
- 引き継ぎ：担当者変更時の学習コスト

::right::

**🎯 意思決定コスト**  
- 設計の迷い：一人で悩む時間
- 技術選定：情報収集と検証の重複
- 方針変更：個人判断による手戻り

---
layout: center
class: text-center
---

# モブワークまとめ

<v-click>

<div class="text-3xl font-bold mb-8 text-gradient">
「個人 vs タスク」から<br>
「チーム vs 問題」への意識変化
</div>

</v-click>

<v-clicks>

## モブワークが促すもの

🤝 **複数の視点と知識を組み合わせた問題解決**  
📖 **個人の暗黙知をリアルタイムでチーム全体に共有**  
🧠 **知識の偏りを減らし、「部族の記憶」を形成**  
🔄 **属人性のないコード・タスク**  
🌱 **チーム全体での学習と成長を促進**  

</v-clicks>

<style>
.text-gradient {
  background: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
</style>

---
layout: section
---

# SECIモデル

---

# SECIモデルの概要
4つのプロセスの頭文字

* **SECI（セキ）モデルとは？**  
個人の知識や経験を組織全体で共有・活用し、新たな知識を創造するサイクル　　
  - 野中郁次郎（のなか・いくじろう）氏らが提唱した知識創造の理論
  - 暗黙知と形式知の相互変換を通じて知識を創造・発展させる
  - 4つのプロセスを繰り返し螺旋状に発展する「知識スパイラル」

---

# 知識創造の4つのプロセス
「暗黙知を形式知に」「形式知を暗黙知に」という変換・移転を繰り返すスパイラル構造

<Transform :scale="0.7">

<img src="/seci-model-diagram.svg" />

</Transform>

---
layout: two-cols-header
---

# 1. 共同化(Socialization) - 暗黙知の直接共有
共通の体験を通じて暗黙知を移転させるプロセス

- **暗黙知 → 暗黙知への変換プロセス**
  - 言葉だけではなく共通の体験や経験を通じて暗黙知を移転
  - 「見て覚える」「一緒に実践する」による学習

::left::

- **共同化の特徴**  
  - 言語化困難な知識の共有  
  「勘」「感覚」「コツ」といった言葉にできない知識  
  熟練者の思考プロセスや判断基準
  - 体験を通じた学習  
  同じ環境で同じ体験を共有  
  リアルタイムでの相互作用

::right::

- **共同化の具体例**  
  - 伝統的な職人の世界  
  師匠と弟子が一緒に作業  
  技術の「見て盗む」文化
  - ビジネス現場  
  OJT（On-the-Job Training）  
  先輩社員との同行営業

---

# モブワークにおける共同化

- **観察と体験の同時進行**  
  - **全員が同じコード・ドキュメントを見ながら作業**
  - ドライバーの思考プロセスをリアルタイムで共有
  - 「なぜこのキーボードショートカットを使うのか」等の微細な技術
- **暗黙知の自然な流出**  
  - **実況（つぶやき）プログラミング**：考えながら声に出すことで暗黙知が表出  
  - 「あ、ここは気をつけないと...」といった無意識の注意点
  - コードを書く際の判断基準や優先順位

<v-clicks>

<div class="box-text-memo">
<b>💡共同化を促進するポイント</b><br />
<li><b>心理的安全性の確保</b>：質問しやすい雰囲気</li>
<li><b>同じ目線</b>での作業：全員が画面を見える環境</li>
<li><b>時間的余裕</b>：急がず観察・体験する時間</li>
<li><b>積極的な参加</b>：受け身ではなく能動的な関与</li>
</div>

</v-clicks>

---

# 2. 表出化(Externalization) - 暗黙知の言語化
個人の暗黙知を言語化し、メンバーと共有するプロセス

- **暗黙知 → 形式知への変換プロセス**  
  - 個人の暗黙知を **言語化・図解化** して他者と共有
  - 「なんとなく分かっている」ことを **明確に説明できる状態** にする
  - 対話や議論を通じて暗黙知を引き出し、形式知として表現
  - 第三者が理解・再現できる状態を作り出す

---
layout: two-cols-header
---

# 2. 表出化(Externalization) - 暗黙知の言語化
個人の暗黙知を言語化し、メンバーと共有するプロセス

::left::

- **表出化の特徴**  
  - **暗黙知の顕在化**  
  無意識に行っていることの意識化  
  「当たり前」と思っていることの明文化  
  個人の経験や判断基準の言語化
  - **共有可能な知識への変換**  
  属人的な知識をチーム資産に変換  
  再現可能な手順やガイドラインの作成  
  知識の標準化と体系化

::right::

- **表出化の具体例**  
  - **ドキュメント化**  
  業務マニュアルの作成  
  設計思想やアーキテクチャの文書化  
  ベストプラクティスの整理  
  FAQ・ナレッジベースの構築
  - **会議・ディスカッション**  
  経験の共有セッション  
  設計レビューでの判断根拠の説明  
  振り返り会議での学びの言語化  
  メンタリングでの知識伝授

---
layout: two-cols-header
---

# モブワークにおける表出化

::left::

* **リアルタイム言語化**  
  - **思考の可視化**：「今、こう考えている」の声出し
  - **判断基準の明示**：「この実装を選ぶ理由は...」  
  - **経験談の共有**：「俺みたいになるな！」
* **議論を通じた知識の引き出し**  
  - **Why**：「なぜその方法を選んだのですか？」
  - **How**：「どう判断をしたのですか？」
  - **What if**：「もし〜だったらどうしますか？」
- **その場でのドキュメント作成**  
  - **コードコメント**の充実：実装意図の明記
  - **ADR(Architecture Decision Record)** の作成  
  - READMEやAPIドキュメントの更新
  - 設計図や図解の作成

::right::

<v-clicks>

<div class="box-text-memo">
<b>💡表出化を促進するポイント</b><br />
<li><b>心理的安全性の確保</b>：間違いを恐れずに発言できる</li>
<li><b>適切な質問技法</b>：オープンエンドな質問で深い思考を引き出す</li>
<li><b>言語化しやすい環境</b>：ツールの活用</li>
<li><b>継続的な振り返り</b>：定期的な振り返りセッション</li>
</div>

</v-clicks>


---
layout: two-cols-header
---

# 3. 連結化(Combination) - 形式知の統合と新知識創出
異なる形式知を組み合わせて新たな知を創出するプロセス

::left::

<Transform :scale="0.9">

- **形式知 → 形式知への変換プロセス**  
  - 異なる **形式知を組み合わせ** て新たな知識体系を構築
  - 既存の知識やデータを **統合・再編成** して新しい価値を創出
  - 複数の情報源から **より網羅性・汎用性の高い知識** を生み出す
- **連結化の特徴**  
  - **知識の統合と組み合わせ**  
  異なる分野・専門領域の知識のクロスオーバー  
  複数の解決策やアプローチの比較検討  
  部分的な知識を組み合わせた全体像の構築
  - **新たな知識体系の創出**  
  既存知識の再構成による新しい視点  
  パターンやフレームワークの発見・構築  
  より効率的・効果的な方法論の開発

</Transform>

::right::

- **連結化の具体例**  
  - **データ分析・情報統合**  
  複数のデータソースの分析結果の統合  
  市場調査レポートとユーザーフィードバックの組み合わせ  
  - **知識の体系化**  
  ベストプラクティス集の編集・整理  
  複数のプロジェクト経験の統合
  - **システム・プロセス設計**  
  異なる技術スタックの組み合わせ  
  複数の開発手法のハイブリッド化

---
layout: two-cols-header
---

# モブワークにおける連結化

::left::

* **多様な知識の即座な統合**  
  - 異なる専門性を持つメンバーの知識の組み合わせ
  - 仮説・根拠の組み合わせから、新しい仮説を立てる
* **リアルタイム知識マッシュアップ**  
  - 異なる意見の組み合わせの検討
  - 設計パターンの組み合わせによる最適解の探索
* **集合知による問題解決**  
  - ブレインストーミング：多角的アイデアの統合
* **振り返りによる新しい気付き**  
  - 「学び」や「反省」を共有して、新しい知識を得る

::right::

<v-clicks>

<div class="box-text-memo">
<b>💡連結化を促進するポイント</b><br />
<li><b>多様性の確保</b>：異なる専門性、経験・背景からの視点の取り入れ</li>
<li><b>リアルタイム情報共有</b>：画面共有、共同編集</li>
<li><b>外部リソース</b>の即座な参照：ドキュメント、リファレンス</li>
<li><b>実験的姿勢</b>失敗を恐れない試行錯誤</li>
</div>

</v-clicks>

---
layout: two-cols-header
---

# 4. 内面化（Internalization）- 形式知の体得と新たな暗黙知の形成
新たに得た形式知を学習学習により体得するプロセス

::left::

- **形式知 → 暗黙知への変換プロセス**  
  - 形式知を **実践を通じて体得** し、個人の暗黙知として習得
  - マニュアルや手順書を **反復練習** により自然に実行できる状態にする
  - 学習した知識を **自分なりの工夫** と組み合わせて新たな暗黙知を創出
  - 知識の個人化と創意工夫による暗黙知の進化

<br />
<br />
<br />
<br />

::right::

- **内面化の特徴**  
  - **実践による知識の定着**  
  頭で理解 → 体で覚えるへの変化  
  意識的実行 → 無意識的実行への移行  
  手順の暗記 → 直感的な判断への発展
  - **個人独自の暗黙知の創出**  
  個人の経験と学んだ知識の融合  
  状況に応じた応用とカスタマイズ  
  新たな気づきや改善アイデアの発見

---
layout: two-cols-header
---

# モブワークにおける内面化

::left::

- **共通した実践体験**  
  - **全員が同じ実践** を通じて同時に内面化
  - **異なる学習速度** を相互にサポート
  - **共通の体験基盤** による暗黙知の共有
- **ローテーションによる深い学習**  
  - **ドライバー交代** により全員が実践を体験
  - **異なる役割** での学習により多角的な理解
  - **教える・教わる** の循環による知識の定着
- **リアルタイムフィードバック**
  - **即座の修正** と **改善提案**
  - **個人の癖** や **思考パターン** の気づき
  - **ベストプラクティス** の自然な習得

<br />

::right::

<v-clicks>

<div class="box-text-memo">
<b>💡内面化を促進するポイント</b><br />
<li><b>観察 → 補助 → 主導</b>の段階的な実践</li>
<li><b>簡単なタスク → 複雑なタスク</b>へのステップアップ</li>
<li><b>振り返りによる意識化</b>: 実践後の振り返りで学びを言語化</li>
<li><b>個人の特性を活かした学習</b>: 個々の学習スタイル及びアプローチ</li>
</div>

</v-clicks>


---
layout: section
---

# SECIモデル4つの場における実践テクニック

---

# SECIモデル4つの場の概要
SECIモデルを支える「場」の重要性

* **🏗️ 「場」とは何か?**
  - 知識創造の各プロセスが **効果的に起こる環境**  
  - 物理的な場所だけでなく、 **関係性や文脈** も含む
  - **適切な場の設計** が知識創造を促進する

---

# 4つの場の全体像
各SECIプロセスには、それを最も効果的に実行できる場が存在

| 場 | 対応プロセス | 知識変換 | 主な目的 | 環境特性 |
|---|---|---|---|---|
| **創発場** | 共同化（Socialization） | 暗黙知→暗黙知 | 体験共有・自然な交流 | インフォーマル・リラックス |
| **対話場** | 表出化（Externalization） | 暗黙知→形式知 | 議論・言語化・明文化 | 構造化・目的志向 |
| **システム場** | 連結化（Combination） | 形式知→形式知 | 統合・組み合わせ・創出 | 情報統合・リアルタイム |
| **実践場** | 内面化（Internalization） | 形式知→暗黙知 | 個人実践・体得・習得 | 個人中心・反復練習 |

---
layout: section
---

# モブワークによる効果的なSECIモデル4つの場の設計
場に合わせてモードを切り替える

---
layout: two-cols-header
---

# 1. 創発場 - 「共同化」を促進するモブモード
🌱 自然な暗黙知交換を促すモード

::left::

## 雑談・交流促進モード

- ✅ 信頼関係構築と心理的安全性の醸成
  - 朝会では発声練習も兼ねての雑談
  - 取り扱い説明書
  - フォロワーシップ

## ローテーション・体験共有モード

- ✅ モブタイマーで定期的なロール交代＆休憩  
  - 15-30分の短サイクルでドライバー交代
  - 全員が同じ体験を共有
  - 休憩時間での自然な振り返り

::right::

## 世代交代・継承モード

- ✅ オンボーディング担当の世代交代  
  - 新人指導役を定期的に変更
  - 教える側の学習効果も狙う
  - 多様な視点での知識伝承

---


- 特徴: 暗黙知を共有する場、経験の直接共有
- モブワークでの実践:
  - 観察モード: ベテランがドライバーとなり、チームが作業プロセスを観察
  - 体験共有モード: 「このコードを書くときはこう考えている」という思考プロセスの声出し
  - ペアモード: 経験者と未経験者がペアになりながらもチーム全体で共有

---

# 2. 対話場 - 「表出化」を促進するモブモード

- 特徴: 暗黙知を言語化し形式知に変換する場
- モブワークでの実践:  
  - 議論モード: チームで設計や実装方針について議論、暗黙知を引き出す質問
  - ドキュメンテーションモード: コードを書きながら同時にコメントやドキュメントを作成
  - 振り返りモード: 「なぜこの実装にしたのか」の理由を言語化する時間を設ける
---

# 3. システム場 - 「連結化」を促進するモブモード

- 特徴: 異なる形式知を組み合わせて新たな知識を創出する場
- モブワークでの実践:  
  - 統合モード: 異なるチームメンバーの知識や経験を組み合わせた実装
  - リファクタリングモード: 既存コードの知識と新しい設計パターンの知識を組み合わせる
  - ワークショップモード: 複数の技術やアプローチを組み合わせる実験的セッション

---

# 4. 実践場 - 「内面化」を促進するモブモード

- 特徴: 形式知を暗黙知として体得する場
- モブワークでの実践:  
  - ローテーションモード: 全員がドライバー役を交代し、実践を通じて学びを内面化
  - チャレンジモード: 新しく学んだ技術や知識を実際に適用してみる
  - コーチングモード: 学んだことを自分の言葉で他者に教える機会を設ける

---

# モブワークでSECIモデルを意識的に回す利点

- 各フェーズに合わせてモブワークのモードを切り替えることで、知識創造のサイクルが加速
- チーム全体が同じ経験を共有しながらも、異なる視点や知識を持ち寄ることができる
- 個人の暗黙知をチーム全体の財産に変換するプロセスが自然に組み込まれる
- 新メンバーの受け入れ時にも、知識共有と創造のサイクルに自然に参加できる


---

# モブプログラミングが開発者のウェルビーイングに与える主なポジティブな影響

* 知識共有と学習の促進  
チームメンバーは互いに学び合い、自身の知識を共有することができます。これにより、チーム全体の理解が深まります。新しい技術や手法を学ぶ機会が増え、特に経験の浅いメンバーにとっては、経験豊富なメンバーから直接学ぶことができるため、学習機会が促進されます。また、新規メンバーのオンボーディングプロセスがスムーズになり、チームに早く馴染むことができます。

* チームコミュニケーションと人間関係の向上  
チーム全体で同じタスクに取り組むため、メンバー間のコミュニケーションが増加し、よりオープンな議論の環境が生まれます。これにより、チーム内の人間関係構築にも良い影響があると報告されています。通常あまり話さないメンバーとも話す機会ができ、良好な関係構築につながるという意見もあります。

* 問題解決の効率化と共同作業による安心感
複雑な問題に取り組む際に、4〜5人のスキルと知識を合わせて議論することで、一人で考えるよりも早く解決策にたどり着けると述べられています。チーム全体で問題に立ち向かうという意識が醸成されます。意見の衝突があった場合でも、グループで扱うことで対処しやすくなるという意見もあります。また、共同で作業することで「ハマりづらくなる」という利点も指摘されています。複数人の視点や知識があるため、一人で思い込みに囚われるリスクが減ります。

* 個人プレッシャーの軽減
タスクをチーム全体で共有して取り組むことで、個人の作業負荷やプレッシャーが軽減されると感じるメンバーもいます。これは、チームと個人レベルの両方に利益をもたらすとされています。

* 属人性の解消とコード品質向上  
チーム全体でコードを共有し、議論しながら書くことで、特定の個人しか理解できないコード（属人性）が解消されます。複数の視点から検討されるため、より質の高いコードが書かれやすくなると考えられています。また、作業中にコードレビューが同時に行われるため、レビューにかかるコストが低減されるというメリットもあります。

* 楽しさ
一緒に作業すること自体を楽しんでいるという意見も聞かれます。

---

# モブプログラミングの潜在的な課題

* チーム内の衝突  
チームメンバー間の衝突が増加する可能性があることが指摘されています。ただし、これが必ずしも悪いわけではないという意見もあれば、ストレスや不快感につながるという意見もあります。特に人間関係に関する衝突は、チームメンバーの満足度と負の相関があることが研究で示唆されています。

* 疲労  
モブプログラミングは集中力が必要なため、疲れると感じるメンバーもいるようです。特に慣れていない場合、負担になる可能性があります。定期的な休憩を取ることが推奨されています。

* 参加度の不均一性  
チームメンバー全員が常に等しく貢献するとは限りません。一部のメンバーが積極的に参加せず、「内職」をしてしまうといった問題が発生する可能性があります。また、議論のスピードについていけないメンバーがいる場合、そのメンバーのモブプログラミング体験が損なわれる可能性があります。

* 個人時間の制約  
すべての開発作業をモブプログラミングで行う場合、個人の学習や業務目標達成のための時間が確保しづらくなるという問題点も指摘されています。

---

モブプログラミングはチームワーク、知識共有、問題解決といった側面から開発者のウェルビーイングに多くのポジティブな影響をもたらす可能性があります。しかし、チーム内の人間関係や個人の特性、適切な役割分担と進行方法などがウェルビーイングに影響を与えるため、これらの課題に適切に対処しながら実践することが重要

---

# モブプログラミングの欠点

* 個人時間の制約  
すべての開発作業をモブプログラミングで行うと、個人の学習や業務目標達成のための時間が確保しづらくなる可能性があります。

* 単純な問題への非効率性  
単純で明確な解がある問題や、並列化可能なタスクには向いていません。

* 集団思考のリスク  
一致団結を重視するあまり、批判的な意見や異なる視点が抑制される「集団思考」に陥る可能性があります。

* 参加度の不均一性  
一部のメンバーが議論についていけない、あるいは内職をしてしまうといった問題が発生する可能性があります。特にエキスパートと初心者の組み合わせでは、理解のギャップや進行速度の差、意思決定の不平等が生じやすいというアンチパターンがあります。

* 疲労  
集中力が必要なため、疲れると感じるメンバーもいます。

* 人間関係の重要性  
メンバー間の尊重、信頼、オープンなコミュニケーションが非常に重要であり、これが欠けると意見の衝突などがストレスにつながる可能性があります。

* ツールや環境の問題  
リモートでの実施では、ツールの設定や接続に問題が生じることがあります。

---

# リモートモブプログラミングを成功させるための要点

1. Remote Everybody  
分散チームで適切に連携するためには、チーム全員がリモートで働くことが不可欠である、という考え方です。一部のメンバーがオンサイトで働き、他のメンバーがリモートで働く状況は、情報格差を引き起こす可能性があります。全員がリモートで働くことで、「遠隔にいるみんな」という状態になり、チームワークの実感が生まれ、孤独感を感じることなく作業に取り組むことができます。これは、リモートワークにおけるコミュニケーションと公平性の確保の重要性を示唆しています。

2. Camera Always On  
カメラを常にオンにして作業するというプラクティスです。これにより、言葉だけでなく全身を使ったコミュニケーションが可能になり、対面で作業しているかのような感覚を得られます。また、チームメンバーの表情が見えることで、集中力が高まり、気が散っている場合にすぐに気づくことができます。最初は違和感があるかもしれませんが、慣れると自然になり、チーム内での一体感を高めるのに役立ちます。メイン画面の近くにカメラを設置することで、お互いを見ながら話すように心がけることが推奨されています。これは、リモート環境での非言語コミュニケーションの不足を補うための重要な要素です。

3. Regular On-Site Meetings  
月に一度など、定期的にオンサイトで集まるというプラクティスです。リモートでのコラボレーションをより円滑にするためには、チームメンバーがお互いをよく知っていることが重要であり、対面での交流はそれを深める最良の方法です。現実世界で一緒に楽しい時間を過ごすことで、チームの絆が強まります。

4. Small Team  
チームサイズを小さく保つことが重要です。Mob Programmingはチーム全体が同じタスクに集中して取り組みますが、リモート環境では同時に話せるのは一人だけです。チームが大きすぎると、個々の発言時間が減り、集中力を維持することが難しくなり、精神的に離脱しやすくなります。また、接続問題やノイズといった技術的な問題が発生した場合に、チーム全体がブロックされる頻度が高まります。Mob Programmingの最小人数は3人ですが、ソースでは4人チームがコストパフォーマンスに優れていると報告されています。4人チームであれば、1人が不在の場合でもMobを組むことが可能です。最適なチームサイズは3〜4人であることが経験的に見出されています。

5. Same Time  
Mob Programmingの前提条件の一つである**「同じ時間に作業する」**ことをリモート環境でも実現します。ソースのチームでは、毎日少なくとも6時間はMob Programmingを行っており、そのためにコアワーキングアワーを調整し、同じランチタイムを共有しています。外部ミーティングや個人的な用事で一時的に離れることは容認されています。

6. Typist and the Rest of the Mob  
「タイピスト (Typist)」「その他のモブ (Rest of the Mob)」独断でコードを書いてはならないという制約が重要です。これにより、全員がプロセスに参加し、強い個性を持つメンバーが支配的になるのを防ぎます。タイピストはナビゲーターの指示を正確に理解し、実装に落とし込む必要があります。

7. Screen Sharing  
タイピストが自分のプライマリスクリーン（IDEを表示している画面）を共有し、チーム全員がそれを見ることで、同じ問題に集中して取り組みます。これは、抽象的な議論ではなく、実際のコードや設計図など、画面上にある形式化されたものを題材に議論することにつながり、効率的な作業を可能にします。ソースでは、共同編集可能なIDEを試した結果、メンバーが議論やタイピストを飛ばして勝手にコードを書き込む問題が発生し、かえってコラボレーションが悪化したため、タイピスト以外はタイピングしないというルールが効果的であると報告されています。リモート環境では、タイピスト以外にはショートカットがなく、言葉で説明する必要があります。画面共有にはZoomのようなツールが使用されます。画面共有の切り替えは、次のMobセッションの開始時に行うことが受け入れられています。

8. 10 Minute Intervals  
タイピストの役割を定期的にローテーションさせることが推奨されており、ソースのチームでは10分間隔でローテーションを行っています。短い間隔でのローテーションは、全員の集中力を維持し、多様な意見を取り入れるのに効果的です。ソースの別の事例では20分間隔でローテーションしており、チームの状況に合わせて適切な間隔を見つけることが重要です。ローテーションをスムーズに行うためにMobsterのようなタイマーアプリが使用されます。ローテーションの際に、ナビゲート中にフラストレーションを感じたメンバーがキーボードを乗っ取って勝手な作業をするリスクが指摘されています。

9. Git Handover  
物理的なキーボードの受け渡しができないリモート環境での課題として、ドライバーの交代をGitを使って行う方法を採用しています。一時的なブランチ上で作業し、インターバルごとにWIP (Work In Progress) コミットをプッシュします。これにより、次のタイピストは最新の状態をプルして作業を引き継ぐことができます。Mobセッションの最後に、これらのWIPコミットをまとめて、意味のあるコミットに整理してからmasterブランチにマージします。このプロセスを効率化するために、専用のツール（mobコマンド）が開発されています。

10. Group Decisions  
Mob Programmingにおいては、すべての決定がチーム全体の合意に基づいた決定となることが強調されています。多様な知識、経験、意見を議論することで、十分に検討された決定を下すことができ、後で覆す必要のあるコストのかかる決定を減らすことができます。これにより、技術的負債を最小限に抑えることができます。コードの変更やコーディングスタイルについても、全員が合意することで、コードレビューやプルリクエストの必要がなくなります。重要な決定については、Architecture Decision Recordsのような形で文書化することが推奨されています。意見の対立があった場合でも、集団での議論を通じて解決を図ります。

11. Constant Momentum  
Mob Programmingでは、チーム全体が同じタスクに集中するため、常に勢いを持続できるというメリットがあります。一人で作業していると、調査が必要になったり、次に何をすべきか分からなくなったりして手が止まることがありますが、Mob Programmingではその他のモブが常に問題を議論し、解決策を考え、次のステップを指示するため、タイピストがブロックされることがありません。これにより、個人で作業するよりもはるかに速いペースで進捗し、やりがいのあるフローに入ることができます。

12. Learn from the Team  
チームメンバー間での継続的な学習と知識共有は、Mob Programmingの中心的なメリットの一つです。すべての作業が詳細な議論の結果として行われるため、なぜそのようにするのかを全員が理解し、そこから学びが得られます。チームメンバーは異なる背景や視点を持っており、ユニットテストの書き方、デバッグ方法、会議の準備の仕方など、様々なスキルや知識を学び合います。新しい技術やフレームワークの学習にも効果的です。また、コードベースの構造やシステム間の相互作用について、チーム全体で共通の理解を持つことができます。経験の浅いメンバーのオンボーディングも促進され、通常よりも短期間でチームに貢献できるようになります。

13. Trust  
リモートワークでは、マネジメントがチームの作業状況を直接「見る」ことができないため、チームの生産性に対する懸念が生じやすいです。リモートMob Programmingでは、チームの自己組織化に対する信頼が不可欠です。この信頼は、チームが積極的にコミュニケーションを取り、コミットメントを常に守り、高品質なコードを期限内に納品することで築かれます。毎日のチェックイン（日々の出来事や計画通りに進まなかったことなどを簡潔に共有）をチャットチャンネルで行うことで、マネジメントもチームの状況を把握し、信頼を深めることができます。

14. Save the Planet  
Mob Programmingは、不要な出張や通勤を減らし、環境負荷を低減するという側面も持っています。リモートMob Programmingであれば、物理的な移動が不要になり、交通渋滞やそれに伴う温室効果ガスの排出を防ぐことができます。これは、環境への配慮という点からもメリットとなり得ます。

15. Dine with your Family  
リモートMob Programmingは、仕事とプライベート（家族との時間など）のバランスを取りやすくするという個人的なメリットも提供します。特に、やりがいのある仕事と家族との質の高い時間を両立することは難しい場合がありますが、リモートで作業することで、通勤時間がなくなり、家族との時間をより多く持つことができるようになります。ソースの執筆者たちは、幼い子供を持つ親であり、この点を重要なメリットとして挙げています。

# モブワークでのリスク

効率の悪いことをやっていると、パフォーマンスの悪化具合が高い

---

# モブワークのテクニック

- 積極的にソロワークへの移行を促す
- 複数モブワークスチーム運用
- 定期的なチームのシャッフル
- 新しいタスク・一定ボリュームのタスクを行った後の振り返り
- 定期的な振り返り共有
- モブタイマーによる定期的なロール入れ替え＆休憩
- 慣れたらリアルタイム共同編集ツール、リアルタイムコラボレーションツールを活用
- 積極的な雑談、お茶会
- オンボーディング担当の世代交代
- その場でのドキュメント作成
- 学びの言語化を習慣化
- 「エキスパート × ビギナー」となった場合に表出化のチャンス

---

# 既存のドキュメント管理だけでは解決できない問題

* プロジェクト初期や試行錯誤段階での未体系化知識の共有の難しさ
* ADRやDesignDocでは捉えきれない「知識が創造される瞬間」の共有
* チームが共に考え、発見する機会の不足

一緒に知識を獲得していく



---

# 未知の課題に対する集合知で取り組んだ事例
ゼロショットでの道の課題にモブで取り込むことにメリット

---

# 参考資料

* [Mob Programming and its impact on the developer's well-being and individual performance](https://www.diva-portal.org/smash/get/diva2:1442517/FULLTEXT01.pdf)
* [Remote Mob Programming](https://www.remotemobprogramming.org/)
* [モブプログラミング入門📖](https://zenn.dev/mossan_hoshi/articles/20230613_mob_programming)